name: Deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write

concurrency:
  group: deploy-production
  cancel-in-progress: false

env:
  IMAGE_NAME: ghcr.io/gianlucafarias/ceres-api

jobs:
  quality-gate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - run: npm ci
      - run: npm run lint:check
      - run: npm test
      - run: npm run build

  build-and-push:
    runs-on: ubuntu-latest
    needs: quality-gate
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4
      - id: meta
        run: echo "image_tag=${GITHUB_SHA}" >> "$GITHUB_OUTPUT"
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:main
            ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.image_tag }}

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: production
    steps:
      - name: Deploy to VPS via SSH
        uses: appleboy/ssh-action@v1.0.3
        env:
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image_tag }}
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT }}
          command_timeout: 30m
          envs: IMAGE_TAG
          script: |
            set -eu
            cd /var/www/ceres-api

            git config --global --add safe.directory /var/www/ceres-api
            git fetch origin main
            git checkout main
            git reset --hard origin/main

            mkdir -p .deploy
            PREVIOUS_IMAGE_ID="$(docker inspect --format='{{.Image}}' ceres-api 2>/dev/null || true)"
            PREVIOUS_TAG="$(cat .deploy/current_api_image_tag 2>/dev/null || echo main)"
            ROLLBACK_TAG="${PREVIOUS_TAG}"
            NEW_TAG="${IMAGE_TAG}"

            if [ -n "${PREVIOUS_IMAGE_ID}" ] && docker image inspect "${PREVIOUS_IMAGE_ID}" >/dev/null 2>&1; then
              docker tag "${PREVIOUS_IMAGE_ID}" "${{ env.IMAGE_NAME }}:rollback-local"
              ROLLBACK_TAG="rollback-local"
            fi

            echo "${{ secrets.GHCR_TOKEN }}" | docker login ghcr.io -u "${{ secrets.GHCR_USERNAME }}" --password-stdin
            if [ -n "${{ secrets.DOCKERHUB_USERNAME }}" ] && [ -n "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
              echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login docker.io -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
            fi
            docker pull "${{ env.IMAGE_NAME }}:${NEW_TAG}"

            if docker compose version >/dev/null 2>&1; then
              COMPOSE_CMD="docker compose"
            elif command -v docker-compose >/dev/null 2>&1; then
              COMPOSE_CMD="docker-compose"
            else
              echo "Docker Compose no esta instalado (ni plugin ni standalone)."
              exit 1
            fi

            get_env_var() {
              local key="$1"
              local fallback="${2:-}"
              if [ ! -f .env ]; then
                echo "${fallback}"
                return
              fi

              local line
              line="$(grep -E "^${key}=" .env | tail -n1 || true)"
              if [ -z "${line}" ]; then
                echo "${fallback}"
                return
              fi

              echo "${line#*=}"
            }

            OBS_STACK_ENABLED="$(get_env_var OBS_STACK_ENABLED false)"

            deploy_api_only() {
              API_IMAGE_TAG="${NEW_TAG}" ${COMPOSE_CMD} up -d --remove-orphans api
            }

            deploy_with_observability() {
              API_IMAGE_TAG="${NEW_TAG}" ${COMPOSE_CMD} \
                -f docker-compose.yml \
                -f docker-compose.observability.yml \
                --profile observability \
                up -d --remove-orphans api prometheus grafana
            }

            if [ "${OBS_STACK_ENABLED}" = "true" ]; then
              set +e
              deploy_with_observability
              OBS_DEPLOY_EXIT=$?
              set -e
              if [ "${OBS_DEPLOY_EXIT}" -ne 0 ]; then
                echo "WARN: observability deploy failed, continuing with API-only deploy."
                deploy_api_only
              fi
            else
              deploy_api_only
            fi

            ATTEMPTS=30
            SLEEP_SECONDS=2
            i=1
            while [ "$i" -le "$ATTEMPTS" ]; do
              STATUS="$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}{{.State.Status}}{{end}}' ceres-api 2>/dev/null || true)"
              if [ "$STATUS" = "healthy" ]; then
                echo "${NEW_TAG}" > .deploy/current_api_image_tag
                docker image prune -f
                exit 0
              fi

              if [ "$STATUS" = "unhealthy" ]; then
                break
              fi

              sleep "$SLEEP_SECONDS"
              i=$((i + 1))
            done

            echo "Deploy failed with tag ${NEW_TAG}. Rolling back to ${ROLLBACK_TAG}."
            rollback_api_only() {
              API_IMAGE_TAG="${ROLLBACK_TAG}" ${COMPOSE_CMD} up -d --remove-orphans api
            }

            rollback_with_observability() {
              API_IMAGE_TAG="${ROLLBACK_TAG}" ${COMPOSE_CMD} \
                -f docker-compose.yml \
                -f docker-compose.observability.yml \
                --profile observability \
                up -d --remove-orphans api prometheus grafana
            }

            if [ "${OBS_STACK_ENABLED}" = "true" ]; then
              set +e
              rollback_with_observability
              OBS_ROLLBACK_EXIT=$?
              set -e
              if [ "${OBS_ROLLBACK_EXIT}" -ne 0 ]; then
                echo "WARN: observability rollback failed, trying API-only rollback."
                rollback_api_only
              fi
            else
              rollback_api_only
            fi

            i=1
            while [ "$i" -le "$ATTEMPTS" ]; do
              STATUS="$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}{{.State.Status}}{{end}}' ceres-api 2>/dev/null || true)"
              if [ "$STATUS" = "healthy" ]; then
                echo "Rollback completed."
                exit 1
              fi

              sleep "$SLEEP_SECONDS"
              i=$((i + 1))
            done

            echo "Rollback failed. Manual intervention required."
            exit 1
